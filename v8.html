<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Pink Christmas Tree</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Noto+Serif+SC:wght@700&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background-color: #020005; font-family: 'Cinzel', serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* è§†é¢‘åé¦ˆæ¡† (å·¦ä¸‹è§’ï¼Œå®æ—¶é¢„è§ˆ) */
        #video-feed { 
            position: absolute; 
            bottom: 30px; 
            left: 30px; 
            width: 180px; 
            height: 135px; 
            border-radius: 12px; 
            border: 2px solid rgba(255, 105, 180, 0.5); 
            z-index: 5; 
            transform: scaleX(-1); /* é•œåƒç¿»è½¬ */
            opacity: 0.8; 
            mix-blend-mode: normal; 
            object-fit: cover;
            box-shadow: 0 0 20px rgba(255, 20, 147, 0.3);
            display: block; 
        }
        
        /* UI å±‚ */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 3; display: flex; flex-direction: column; align-items: center; justify-content: flex-start; padding-top: 8vh; }
        
        /* æ ‡é¢˜è®¾è®¡ */
        .title-group { text-align: center; animation: glowText 4s ease-in-out infinite alternate; }
        h1 { margin: 0; font-weight: 700; font-size: 3.5rem; letter-spacing: 5px; 
             color: #fff;
             background: linear-gradient(180deg, #fff 30%, #ff9a9e 100%);
             -webkit-background-clip: text; -webkit-text-fill-color: transparent;
             filter: drop-shadow(0 0 15px rgba(255, 20, 147, 0.8)); }
        h2 { margin: 15px 0 0 0; font-weight: 400; font-size: 1.5rem; letter-spacing: 8px; color: #FFB6C1; 
             font-family: 'Noto Serif SC', serif; text-shadow: 0 0 10px rgba(255, 182, 193, 0.5); }
        
        @keyframes glowText { from { filter: drop-shadow(0 0 10px rgba(255, 20, 147, 0.6)); } to { filter: drop-shadow(0 0 20px rgba(255, 20, 147, 1)); } }

        /* çŠ¶æ€ä¸åŠ è½½ */
        .status-container { position: absolute; top: 20px; left: 20px; text-align: left; }
        .status { margin-top: 5px; font-size: 12px; color: #ff8fa3; opacity: 0.8; font-family: 'Noto Serif SC', serif; }
        
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #FF69B4; z-index: 10; font-size: 16px; letter-spacing: 2px; text-align: center; background: rgba(0,0,0,0.8); padding: 20px; border-radius: 10px; width: 300px;}
        
        /* åº•éƒ¨æ“ä½œè¯´æ˜ */
        .footer-instruction { 
            position: absolute; 
            bottom: 40px; 
            width: 100%; 
            text-align: center; 
            z-index: 2; 
            pointer-events: none; 
        }
        .gesture-list {
            display: inline-flex;
            gap: 30px;
            background: rgba(0, 0, 0, 0.4);
            padding: 15px 40px;
            border-radius: 50px;
            border: 1px solid rgba(255, 105, 180, 0.3);
            backdrop-filter: blur(5px);
        }
        .gesture-item {
            color: #ffcce0;
            font-family: 'Noto Serif SC', serif;
            font-size: 14px;
            letter-spacing: 1px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .gesture-icon { font-size: 18px; }
        
        #upload-btn { position: absolute; top: 20px; right: 20px; z-index: 4; padding: 8px 20px; background: rgba(255,20,147,0.2); border: 1px solid #FF1493; color: #fff; cursor: pointer; border-radius: 20px; pointer-events: auto; font-family: 'Noto Serif SC', serif; transition: 0.3s;}
        #upload-btn:hover { background: #FF1493; box-shadow: 0 0 15px #FF1493; }
        input[type="file"] { display: none; }
    </style>
    
    <!-- ä¾èµ–åº“ï¼šæ·»åŠ  crossorigin å±æ€§å°è¯•è§£å†³è·¨åŸŸ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js" crossorigin="anonymous"></script>
    
    <!-- PostProcessing -->
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js" crossorigin="anonymous"></script>
    
    <!-- MediaPipe (ä½¿ç”¨ jsdelivrï¼Œé€Ÿåº¦è¾ƒå¿«) -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">
        âœ¨ æ­£åœ¨ç‚¹äº®ç²‰è‰²æ˜Ÿæ²³...<br>
        <span style="font-size:12px; opacity:0.7; margin-top:10px; display:block">å¦‚æœé•¿æ—¶é—´æœªå“åº”ï¼š<br>1. è¯·å…è®¸æ‘„åƒå¤´æƒé™<br>2. å°è¯•ä½¿ç”¨Chromeæµè§ˆå™¨</span>
    </div>

    <div id="ui-layer">
        <div class="title-group">
            <h1>ç¨‹å“è€å©†ç”Ÿæ—¥å¿«ä¹ï¼</h1>
            <h2>é¢†è¯ä¸€å‘¨å¹´å¿«ä¹ï¼</h2>
        </div>
        <div class="status-container">
            <div class="status">ç³»ç»ŸçŠ¶æ€: <span id="gesture-detected" style="color:#fff; font-weight:bold">æ­£åœ¨åˆå§‹åŒ–æ‘„åƒå¤´...</span></div>
        </div>
    </div>

    <!-- åº•éƒ¨æ“ä½œè¯´æ˜ -->
    <div class="footer-instruction">
        <div class="gesture-list">
            <span class="gesture-item"><span class="gesture-icon">âœŠ</span> æ¡æ‹³ï¼šèšåˆ</span>
            <span class="gesture-item"><span class="gesture-icon">ğŸ–</span> å¼ å¼€ï¼šæ•£å¼€</span>
            <span class="gesture-item"><span class="gesture-icon">ğŸ‘‹</span> ç§»åŠ¨ï¼šæ—‹è½¬</span>
            <span class="gesture-item"><span class="gesture-icon">ğŸ¤</span> æåˆï¼šæŠ“å–</span>
        </div>
    </div>
    
    <button id="upload-btn" onclick="document.getElementById('file-input').click()">ä¸Šä¼ ç…§ç‰‡</button>
    <input type="file" id="file-input" multiple accept="image/*">

    <!-- è§†é¢‘é¢„è§ˆ (æ·»åŠ  autoplay playsinline muted) -->
    <video id="video-feed" autoplay playsinline muted></video>
    <div id="canvas-container"></div>

    <script>
        // -----------------------------------------------------------
        // 1. é…ç½®å‚æ•°
        // -----------------------------------------------------------
        const CONFIG = {
            particleCount: 8500,    
            spiralPoints: 900,      
            heartPoints: 600,       
            layers: 6,              
            treeHeight: 35,
            baseRadius: 14,
            colors: {
                pink: new THREE.Color(0xFF1493),    
                lightPink: new THREE.Color(0xFF69B4), 
                white: new THREE.Color(0xFFFFFF),
                gold: new THREE.Color(0xFFD700)
            },
            bloom: { strength: 2.0, radius: 0.6, threshold: 0.15 } 
        };

        const STATE = {
            mode: 'TREE', 
            targetRotationY: 0,
            time: 0
        };

        let scene, camera, renderer, composer;
        let treeSystem, spiralSystem, heartSystem, snowSystem;
        let treeData = [], spiralData = [], heartData = [];

        // -----------------------------------------------------------
        // 2. çº¹ç†ç”Ÿæˆå·¥å…·
        // -----------------------------------------------------------
        function createSharpDot() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(0.3, 'rgba(255,255,255,0.8)');
            grad.addColorStop(0.5, 'rgba(255,255,255,0.2)');
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 32, 32);
            return new THREE.CanvasTexture(canvas);
        }

        function createShapeTexture(type) {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = "#FFFFFF";
            ctx.shadowBlur = 5; ctx.shadowColor = "#FF69B4";
            
            const cx = 32, cy = 32;

            if (type === 'star') {
                const outerRadius = 24, innerRadius = 10;
                ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    ctx.lineTo(Math.cos((18 + i * 72) / 180 * Math.PI) * outerRadius + cx,
                               -Math.sin((18 + i * 72) / 180 * Math.PI) * outerRadius + cy);
                    ctx.lineTo(Math.cos((54 + i * 72) / 180 * Math.PI) * innerRadius + cx,
                               -Math.sin((54 + i * 72) / 180 * Math.PI) * innerRadius + cy);
                }
                ctx.closePath();
            } else if (type === 'heart') {
                ctx.beginPath();
                ctx.moveTo(32, 54);
                ctx.bezierCurveTo(32, 51, 10, 37, 10, 20);
                ctx.bezierCurveTo(10, 5, 32, 5, 32, 20);
                ctx.bezierCurveTo(32, 5, 54, 5, 54, 20);
                ctx.bezierCurveTo(54, 37, 32, 51, 32, 54);
            }
            ctx.fill();
            return new THREE.CanvasTexture(canvas);
        }

        const texDot = createSharpDot();
        const texStar = createShapeTexture('star');
        const texHeart = createShapeTexture('heart');

        // -----------------------------------------------------------
        // 3. åœºæ™¯åˆå§‹åŒ–
        // -----------------------------------------------------------
        function initThree() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x020005, 0.02);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 15, 55);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ReinhardToneMapping;
            container.appendChild(renderer.domElement);

            const renderScene = new THREE.RenderPass(scene, camera);
            
            if (THREE.UnrealBloomPass) {
                const bloomPass = new THREE.UnrealBloomPass(
                    new THREE.Vector2(window.innerWidth, window.innerHeight),
                    CONFIG.bloom.strength, CONFIG.bloom.radius, CONFIG.bloom.threshold
                );
                composer = new THREE.EffectComposer(renderer);
                composer.addPass(renderScene);
                composer.addPass(bloomPass);
            } else {
                composer = null;
            }

            createLayeredTree();
            createSpiralLine();
            create3DHeart();
            createBackgroundSnow();

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                if(composer) composer.setSize(window.innerWidth, window.innerHeight);
            });
            
            animate();
        }

        // -----------------------------------------------------------
        // 4. æ ‘ç”Ÿæˆé€»è¾‘
        // -----------------------------------------------------------
        function createLayeredTree() {
            const createSubSystem = (count, texture, sizeMod) => {
                const geo = new THREE.BufferGeometry();
                const positions = [];
                const colors = [];
                const sizes = [];
                const phases = [];

                const layerHeight = CONFIG.treeHeight / CONFIG.layers;

                for(let i=0; i<count; i++) {
                    const layerIndex = Math.floor(Math.random() * CONFIG.layers);
                    const layerProgress = Math.random(); 
                    const y = (layerIndex + layerProgress) * layerHeight; 
                    
                    let rBase = (1 - y/CONFIG.treeHeight) * CONFIG.baseRadius;
                    let rLayerMod = (1 - layerProgress) * 2.5; 
                    let r = rBase + rLayerMod;
                    
                    const radiusSample = Math.sqrt(Math.random()) * r;
                    const angle = Math.random() * Math.PI * 2;
                    const x = Math.cos(angle) * radiusSample;
                    const z = Math.sin(angle) * radiusSample;
                    const finalY = y - CONFIG.treeHeight / 2 + 5;

                    positions.push(x, finalY, z);

                    const colorMix = Math.random();
                    const c = new THREE.Color();
                    if(colorMix > 0.9) c.copy(CONFIG.colors.white);
                    else if (colorMix > 0.6) c.copy(CONFIG.colors.lightPink);
                    else c.copy(CONFIG.colors.pink);
                    
                    colors.push(c.r, c.g, c.b);
                    sizes.push((Math.random() * 0.6 + 0.4) * sizeMod);
                    phases.push(Math.random() * Math.PI * 2);

                    treeData.push({
                        base: new THREE.Vector3(x, finalY, z),
                        scatter: new THREE.Vector3((Math.random()-0.5)*80, (Math.random()-0.5)*80, (Math.random()-0.5)*80),
                        geoIndex: i * 3,
                        system: geo
                    });
                }

                geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
                geo.setAttribute('phase', new THREE.Float32BufferAttribute(phases, 1));

                const mat = new THREE.PointsMaterial({
                    size: 0.6,
                    map: texture,
                    vertexColors: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false,
                    transparent: true,
                    opacity: 0.95
                });

                const mesh = new THREE.Points(geo, mat);
                scene.add(mesh);
                return mesh;
            };

            const total = CONFIG.particleCount;
            treeSystem = {
                dots: createSubSystem(total * 0.8, texDot, 1.0),
                stars: createSubSystem(total * 0.1, texStar, 1.5),
                hearts: createSubSystem(total * 0.1, texHeart, 1.5)
            };
        }

        function createSpiralLine() {
            const geo = new THREE.BufferGeometry();
            const positions = [];
            const sizes = [];
            const loops = 6; 
            
            for(let i=0; i<CONFIG.spiralPoints; i++) {
                const progress = i / CONFIG.spiralPoints;
                const angle = progress * Math.PI * 2 * loops;
                const y = progress * CONFIG.treeHeight - CONFIG.treeHeight/2 + 5;
                const r = ((1 - progress) * CONFIG.baseRadius + 2.5) * 1.1;
                
                const x = Math.cos(angle) * r;
                const z = Math.sin(angle) * r;

                positions.push(x, y, z);
                sizes.push(1.2);

                spiralData.push({
                    base: new THREE.Vector3(x, y, z),
                    angleOffset: angle,
                    radius: r,
                    y: y
                });
            }

            geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

            const mat = new THREE.PointsMaterial({
                color: 0xFFFFFF,
                size: 1.0,
                map: texDot,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 1.0
            });

            spiralSystem = new THREE.Points(geo, mat);
            scene.add(spiralSystem);
        }

        function create3DHeart() {
            const geo = new THREE.BufferGeometry();
            const positions = [];
            const sizes = [];
            
            for(let i=0; i<CONFIG.heartPoints; i++) {
                let done = false;
                while(!done) {
                    const x = (Math.random() - 0.5) * 3;
                    const y = (Math.random() - 0.5) * 3;
                    const z = (Math.random() - 0.5) * 3;
                    
                    const a = x;
                    const b = y * 1.2; 
                    const c = z;
                    const eq = Math.pow(a*a + 2.25*b*b + c*c - 1, 3) - a*a*c*c*c - 0.1125*b*b*c*c*c;
                    
                    if(eq < 0) {
                        const startY = CONFIG.treeHeight/2 + 7;
                        positions.push(x * 1.5, y * 1.5 + startY, z * 1.5);
                        sizes.push(Math.random() * 0.5 + 0.5);
                        
                        heartData.push({
                            relX: x * 1.5,
                            relY: y * 1.5,
                            relZ: z * 1.5,
                            treeCenterY: startY,
                            centerTarget: new THREE.Vector3(x * 3, y * 3 + 15, z * 3 + 30)
                        });
                        done = true;
                    }
                }
            }

            geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

            const mat = new THREE.PointsMaterial({
                color: 0xFF1493, 
                size: 1.0,
                map: texDot, 
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0.8
            });

            heartSystem = new THREE.Points(geo, mat);
            scene.add(heartSystem);
        }

        function createBackgroundSnow() {
            const geo = new THREE.BufferGeometry();
            const positions = [];
            for(let i=0; i<400; i++) {
                positions.push(
                    (Math.random() - 0.5) * 150,
                    Math.random() * 100 - 50,
                    (Math.random() - 0.5) * 100 - 20
                );
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            const mat = new THREE.PointsMaterial({
                color: 0xFFFFFF,
                size: 0.8,
                map: texHeart,
                transparent: true,
                opacity: 0.3,
                blending: THREE.AdditiveBlending
            });
            snowSystem = new THREE.Points(geo, mat);
            scene.add(snowSystem);
        }

        // -----------------------------------------------------------
        // 5. åŠ¨ç”»å¾ªç¯
        // -----------------------------------------------------------
        function animate() {
            requestAnimationFrame(animate);
            STATE.time += 0.015;

            // æ ‘æ›´æ–°
            const systems = [treeSystem.dots, treeSystem.stars, treeSystem.hearts];
            systems.forEach(sys => {
                if (STATE.mode === 'TREE') {
                    sys.rotation.y = STATE.time * 0.1;
                } else {
                    sys.rotation.y += (STATE.targetRotationY - sys.rotation.y) * 0.05;
                }
            });

            for(let i=0; i<treeData.length; i++) {
                const d = treeData[i];
                const positions = d.system.geometry.attributes.position.array;
                const idx = d.geoIndex;
                let target;
                
                if(STATE.mode === 'TREE') {
                    target = d.base;
                } else {
                    target = d.scatter;
                }
                positions[idx] += (target.x - positions[idx]) * 0.05;
                positions[idx+1] += (target.y - positions[idx+1]) * 0.05;
                positions[idx+2] += (target.z - positions[idx+2]) * 0.05;
            }
            systems.forEach(sys => sys.geometry.attributes.position.needsUpdate = true);

            // èºæ—‹çº¿æ›´æ–°
            const spiralPos = spiralSystem.geometry.attributes.position.array;
            for(let i=0; i<CONFIG.spiralPoints; i++) {
                const i3 = i * 3;
                const d = spiralData[i];
                
                if(STATE.mode === 'TREE') {
                    const currentAngle = d.angleOffset - STATE.time * 0.5;
                    const x = Math.cos(currentAngle) * d.radius;
                    const z = Math.sin(currentAngle) * d.radius;
                    spiralPos[i3] += (x - spiralPos[i3]) * 0.1;
                    spiralPos[i3+1] += (d.y - spiralPos[i3+1]) * 0.1;
                    spiralPos[i3+2] += (z - spiralPos[i3+2]) * 0.1;
                } else {
                    spiralPos[i3] += (d.base.x * 2 - spiralPos[i3]) * 0.05;
                    spiralPos[i3+1] += (d.base.y - spiralPos[i3+1]) * 0.05;
                    spiralPos[i3+2] += (d.base.z * 2 - spiralPos[i3+2]) * 0.05;
                }
            }
            spiralSystem.geometry.attributes.position.needsUpdate = true;

            // çˆ±å¿ƒæ›´æ–°
            const heartPos = heartSystem.geometry.attributes.position.array;
            if (STATE.mode === 'TREE') {
                 heartSystem.rotation.y = -STATE.time * 0.8;
            } else {
                 heartSystem.rotation.y += (0 - heartSystem.rotation.y) * 0.05; 
            }

            for(let i=0; i<CONFIG.heartPoints; i++) {
                const i3 = i * 3;
                const d = heartData[i];
                let tx, ty, tz;

                if (STATE.mode === 'TREE') {
                    tx = d.relX;
                    ty = d.relY + d.treeCenterY;
                    tz = d.relZ;
                } else {
                    tx = d.centerTarget.x;
                    ty = d.centerTarget.y;
                    tz = d.centerTarget.z;
                }
                heartPos[i3] += (tx - heartPos[i3]) * 0.05;
                heartPos[i3+1] += (ty - heartPos[i3+1]) * 0.05;
                heartPos[i3+2] += (tz - heartPos[i3+2]) * 0.05;
            }
            heartSystem.geometry.attributes.position.needsUpdate = true;

            // é›ªèŠ±
            const snowP = snowSystem.geometry.attributes.position.array;
            for(let i=0; i<400; i++) {
                const i3 = i * 3;
                snowP[i3+1] -= 0.05;
                if(snowP[i3+1] < -20) snowP[i3+1] = 40;
            }
            snowSystem.geometry.attributes.position.needsUpdate = true;

            if(composer) composer.render();
            else renderer.render(scene, camera);
        }

        // -----------------------------------------------------------
        // MediaPipe åˆå§‹åŒ–é€»è¾‘ (ä¿®å¤éƒ¨åˆ†)
        // -----------------------------------------------------------
        async function initMediaPipe() {
            const videoElement = document.getElementById('video-feed');
            const statusElement = document.getElementById('gesture-detected');
            
            // å»¶è¿Ÿä»¥è®©3Dæ¸²æŸ“å…ˆåˆå§‹åŒ–
            await new Promise(r => setTimeout(r, 1500));

            // å®‰å…¨æ£€æŸ¥ï¼šå¦‚æœMediaPipeæœªåŠ è½½ï¼Œåˆ™ä¸è¿è¡Œ
            if (typeof Hands === 'undefined' || typeof Camera === 'undefined') {
                document.getElementById('loading').style.display = 'none';
                statusElement.innerText = "è§†è§‰æ¨¡å—åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œ";
                return;
            }

            try {
                const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
                
                hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 0, // æ€§èƒ½ä¼˜å…ˆ
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                
                hands.onResults((results) => {
                    // ç¬¬ä¸€æ¬¡æˆåŠŸè·å–ç»“æœæ—¶ï¼Œéšè—loading
                    const loader = document.getElementById('loading');
                    if (loader && loader.style.display !== 'none') {
                         loader.style.display = 'none';
                    }

                    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                        detectGesture(results.multiHandLandmarks[0]);
                    } else {
                        statusElement.innerText = "æœªæ£€æµ‹åˆ°æ‰‹";
                    }
                });

                const cameraFeed = new Camera(videoElement, {
                    onFrame: async () => { await hands.send({image: videoElement}); },
                    width: 320,
                    height: 240
                });
                
                // è®¾ç½®è¶…æ—¶é™çº§ï¼šå¦‚æœ10ç§’å†…æ²¡æœ‰ç”»é¢ï¼Œå¼ºåˆ¶éšè—Loadingï¼Œè®©ç”¨æˆ·çœ‹åŠ¨ç”»
                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                }, 10000);

                await cameraFeed.start();
                
            } catch (error) {
                console.error("Camera Init Failed:", error);
                document.getElementById('loading').style.display = 'none';
                statusElement.innerText = "æ‘„åƒå¤´æ— æ³•å¯åŠ¨";
            }
        }

        function detectGesture(landmarks) {
            const dist = (i, j) => Math.hypot(landmarks[i].x - landmarks[j].x, landmarks[i].y - landmarks[j].y);
            
            const thumbTip = 4, indexTip = 8, palm = 9;
            const pinch = dist(thumbTip, indexTip);
            const handX = landmarks[palm].x;

            let gesture = 'ğŸŒ² æ¬£èµæ¨¡å¼';
            
            if (pinch < 0.05) {
                gesture = 'ğŸ¤ æŠ“å–æ˜Ÿå…‰';
            } else if (dist(8, 0) > 0.4) { // é£ŸæŒ‡ä¼¸ç›´è¿œç¦»æ‰‹è…•
                gesture = 'ğŸ– æ•£å¼€æ˜Ÿå°˜';
                STATE.mode = 'SCATTER';
            } else {
                // é»˜è®¤æ¡æ‹³æˆ–å…¶ä»–çŠ¶æ€èšåˆ
                STATE.mode = 'TREE';
                gesture = 'âœŠ èšåˆå›å¿†';
            }
            
            if (STATE.mode === 'SCATTER') {
                STATE.targetRotationY = (handX - 0.5) * -3;
            }

            document.getElementById('gesture-detected').innerText = gesture;
        }

        document.getElementById('file-input').addEventListener('change', (e) => {
            if(e.target.files.length) alert("ç…§ç‰‡å·²ä¸Šä¼ åˆ°é­”æ³•åº“ï¼");
        });

        initThree();
        initMediaPipe();

    </script>
</body>
</html>
