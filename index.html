<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Pink Christmas Tree</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Noto+Serif+SC:wght@700&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background-color: #020005; font-family: 'Cinzel', serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* è§†é¢‘åé¦ˆæ¡† */
        #video-feed { 
            position: absolute; bottom: 30px; left: 30px; width: 180px; height: 135px; 
            border-radius: 12px; border: 2px solid rgba(255, 105, 180, 0.5); 
            z-index: 5; transform: scaleX(-1); opacity: 0.8; object-fit: cover;
            box-shadow: 0 0 20px rgba(255, 20, 147, 0.3); display: block; 
        }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 3; display: flex; flex-direction: column; align-items: center; justify-content: flex-start; padding-top: 8vh; }
        
        .title-group { text-align: center; animation: glowText 4s ease-in-out infinite alternate; }
        h1 { margin: 0; font-weight: 700; font-size: 3.5rem; letter-spacing: 5px; color: #fff; background: linear-gradient(180deg, #fff 30%, #ff9a9e 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; filter: drop-shadow(0 0 15px rgba(255, 20, 147, 0.8)); }
        h2 { margin: 15px 0 0 0; font-weight: 400; font-size: 1.5rem; letter-spacing: 8px; color: #FFB6C1; font-family: 'Noto Serif SC', serif; text-shadow: 0 0 10px rgba(255, 182, 193, 0.5); }
        @keyframes glowText { from { filter: drop-shadow(0 0 10px rgba(255, 20, 147, 0.6)); } to { filter: drop-shadow(0 0 20px rgba(255, 20, 147, 1)); } }

        .status-container { position: absolute; top: 20px; left: 20px; text-align: left; }
        .status { margin-top: 5px; font-size: 12px; color: #ff8fa3; opacity: 0.8; font-family: 'Noto Serif SC', serif; }
        
        /* åŠ è½½å±‚ä¼˜åŒ–ï¼šé»˜è®¤éšè—ï¼Œç”±JSæ§åˆ¶æ˜¾ç¤ºï¼Œè¶…æ—¶è‡ªåŠ¨æ¶ˆå¤± */
        #loading { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            color: #FF69B4; z-index: 10; font-size: 14px; letter-spacing: 2px; text-align: center; 
            background: rgba(0,0,0,0.8); padding: 20px; border-radius: 12px; border: 1px solid #FF1493;
            transition: opacity 0.5s;
        }
        
        .footer-instruction { position: absolute; bottom: 40px; width: 100%; text-align: center; z-index: 2; pointer-events: none; }
        .gesture-list { display: inline-flex; gap: 30px; background: rgba(0, 0, 0, 0.4); padding: 15px 40px; border-radius: 50px; border: 1px solid rgba(255, 105, 180, 0.3); backdrop-filter: blur(5px); }
        .gesture-item { color: #ffcce0; font-family: 'Noto Serif SC', serif; font-size: 14px; letter-spacing: 1px; display: flex; align-items: center; gap: 8px; }
        .gesture-icon { font-size: 18px; }
        
        #upload-btn { position: absolute; top: 20px; right: 20px; z-index: 4; padding: 8px 20px; background: rgba(255,20,147,0.2); border: 1px solid #FF1493; color: #fff; cursor: pointer; border-radius: 20px; pointer-events: auto; font-family: 'Noto Serif SC', serif; transition: 0.3s;}
        #upload-btn:hover { background: #FF1493; box-shadow: 0 0 15px #FF1493; }
        input[type="file"] { display: none; }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js" crossorigin="anonymous"></script>
    
    <!-- æ›¿æ¢ä¸º unpkg æºï¼Œæœ‰æ—¶å€™æ¯” jsdelivr æ›´ç¨³å®š -->
    <script src="https://unpkg.com/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">
        âœ¨ æ­£åœ¨å¯åŠ¨é­”æ³•å¼•æ“...<br>
        <span style="font-size:12px; opacity:0.8; margin-top:10px; display:block; color:white">
            å¦‚æœç”»é¢å¡ä½ï¼Œè¯·æ£€æŸ¥æµè§ˆå™¨æ˜¯å¦æ‹¦æˆªäº†æ‘„åƒå¤´æƒé™<br>æˆ–è€…ç›´æ¥ç‚¹å‡»å±å¹•å¼€å§‹
        </span>
    </div>

    <div id="ui-layer">
        <div class="title-group">
            <h1>ç¨‹å“è€å©†ç”Ÿæ—¥å¿«ä¹ï¼</h1>
            <h2>é¢†è¯ä¸€å‘¨å¹´å¿«ä¹ï¼</h2>
        </div>
        <div class="status-container">
            <div class="status">ç³»ç»ŸçŠ¶æ€: <span id="gesture-detected" style="color:#fff; font-weight:bold">ç­‰å¾…æ‰‹åŠ¿...</span></div>
        </div>
    </div>

    <div class="footer-instruction">
        <div class="gesture-list">
            <span class="gesture-item"><span class="gesture-icon">âœŠ</span> æ¡æ‹³ï¼šèšåˆ</span>
            <span class="gesture-item"><span class="gesture-icon">ğŸ–</span> å¼ å¼€ï¼šæ•£å¼€</span>
            <span class="gesture-item"><span class="gesture-icon">ğŸ‘‹</span> ç§»åŠ¨ï¼šæ—‹è½¬</span>
            <span class="gesture-item"><span class="gesture-icon">ğŸ¤</span> æåˆï¼šæŠ“å–</span>
        </div>
    </div>
    
    <button id="upload-btn" onclick="document.getElementById('file-input').click()">ä¸Šä¼ ç…§ç‰‡</button>
    <input type="file" id="file-input" multiple accept="image/*">

    <video id="video-feed" autoplay playsinline muted></video>
    <div id="canvas-container"></div>

    <script>
        // é…ç½®
        const CONFIG = {
            particleCount: 8500,    
            spiralPoints: 900,      
            heartPoints: 600,       
            layers: 6,              
            treeHeight: 35,
            baseRadius: 14,
            colors: {
                pink: new THREE.Color(0xFF1493),    
                lightPink: new THREE.Color(0xFF69B4), 
                white: new THREE.Color(0xFFFFFF),
                gold: new THREE.Color(0xFFD700)
            },
            bloom: { strength: 2.0, radius: 0.6, threshold: 0.15 } 
        };

        const STATE = { mode: 'TREE', targetRotationY: 0, time: 0 };

        let scene, camera, renderer, composer;
        let treeSystem, spiralSystem, heartSystem, snowSystem;
        let treeData = [], spiralData = [], heartData = [];

        // çº¹ç†ç”Ÿæˆ
        function createSharpDot() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(0.3, 'rgba(255,255,255,0.8)');
            grad.addColorStop(0.5, 'rgba(255,255,255,0.2)');
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 32, 32);
            return new THREE.CanvasTexture(canvas);
        }

        function createShapeTexture(type) {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = "#FFFFFF";
            ctx.shadowBlur = 5; ctx.shadowColor = "#FF69B4";
            const cx = 32, cy = 32;

            if (type === 'star') {
                const outerRadius = 24, innerRadius = 10;
                ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    ctx.lineTo(Math.cos((18 + i * 72) / 180 * Math.PI) * outerRadius + cx, -Math.sin((18 + i * 72) / 180 * Math.PI) * outerRadius + cy);
                    ctx.lineTo(Math.cos((54 + i * 72) / 180 * Math.PI) * innerRadius + cx, -Math.sin((54 + i * 72) / 180 * Math.PI) * innerRadius + cy);
                }
                ctx.closePath();
            } else if (type === 'heart') {
                ctx.beginPath();
                ctx.moveTo(32, 54);
                ctx.bezierCurveTo(32, 51, 10, 37, 10, 20);
                ctx.bezierCurveTo(10, 5, 32, 5, 32, 20);
                ctx.bezierCurveTo(32, 5, 54, 5, 54, 20);
                ctx.bezierCurveTo(54, 37, 32, 51, 32, 54);
            }
            ctx.fill();
            return new THREE.CanvasTexture(canvas);
        }

        const texDot = createSharpDot();
        const texStar = createShapeTexture('star');
        const texHeart = createShapeTexture('heart');

        // åˆå§‹åŒ– Three.js
        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x020005, 0.02);
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 15, 55);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ReinhardToneMapping;
            container.appendChild(renderer.domElement);

            if (THREE.UnrealBloomPass) {
                const renderScene = new THREE.RenderPass(scene, camera);
                const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), CONFIG.bloom.strength, CONFIG.bloom.radius, CONFIG.bloom.threshold);
                composer = new THREE.EffectComposer(renderer);
                composer.addPass(renderScene);
                composer.addPass(bloomPass);
            } else { composer = null; }

            createLayeredTree();
            createSpiralLine();
            create3DHeart();
            createBackgroundSnow();

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                if(composer) composer.setSize(window.innerWidth, window.innerHeight);
            });
            animate();
            
            // å¼ºåˆ¶ç§»é™¤ Loading é®ç½©ï¼ˆå¦‚æœ5ç§’åè¿˜åœ¨ï¼‰
            setTimeout(() => {
                const loader = document.getElementById('loading');
                if(loader) loader.style.opacity = 0;
                setTimeout(() => { if(loader) loader.style.display = 'none'; }, 500);
            }, 5000);
        }

        // åˆ›å»ºå„éƒ¨åˆ†
        function createLayeredTree() {
            const createSubSystem = (count, texture, sizeMod) => {
                const geo = new THREE.BufferGeometry();
                const positions = [], colors = [], sizes = [], phases = [];
                const layerHeight = CONFIG.treeHeight / CONFIG.layers;

                for(let i=0; i<count; i++) {
                    const layerIndex = Math.floor(Math.random() * CONFIG.layers);
                    const layerProgress = Math.random(); 
                    const y = (layerIndex + layerProgress) * layerHeight; 
                    let rBase = (1 - y/CONFIG.treeHeight) * CONFIG.baseRadius;
                    let rLayerMod = (1 - layerProgress) * 2.5; 
                    let r = rBase + rLayerMod;
                    const radiusSample = Math.sqrt(Math.random()) * r;
                    const angle = Math.random() * Math.PI * 2;
                    const x = Math.cos(angle) * radiusSample;
                    const z = Math.sin(angle) * radiusSample;
                    const finalY = y - CONFIG.treeHeight / 2 + 5;

                    positions.push(x, finalY, z);
                    const colorMix = Math.random();
                    const c = new THREE.Color();
                    if(colorMix > 0.9) c.copy(CONFIG.colors.white);
                    else if (colorMix > 0.6) c.copy(CONFIG.colors.lightPink);
                    else c.copy(CONFIG.colors.pink);
                    
                    colors.push(c.r, c.g, c.b);
                    sizes.push((Math.random() * 0.6 + 0.4) * sizeMod);
                    phases.push(Math.random() * Math.PI * 2);

                    treeData.push({ base: new THREE.Vector3(x, finalY, z), scatter: new THREE.Vector3((Math.random()-0.5)*80, (Math.random()-0.5)*80, (Math.random()-0.5)*80), geoIndex: i * 3, system: geo });
                }
                geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
                geo.setAttribute('phase', new THREE.Float32BufferAttribute(phases, 1));
                const mat = new THREE.PointsMaterial({ size: 0.6, map: texture, vertexColors: true, blending: THREE.AdditiveBlending, depthWrite: false, transparent: true, opacity: 0.95 });
                const mesh = new THREE.Points(geo, mat);
                scene.add(mesh);
                return mesh;
            };
            const total = CONFIG.particleCount;
            treeSystem = { dots: createSubSystem(total * 0.8, texDot, 1.0), stars: createSubSystem(total * 0.1, texStar, 1.5), hearts: createSubSystem(total * 0.1, texHeart, 1.5) };
        }

        function createSpiralLine() {
            const geo = new THREE.BufferGeometry();
            const positions = [], sizes = [];
            const loops = 6; 
            for(let i=0; i<CONFIG.spiralPoints; i++) {
                const progress = i / CONFIG.spiralPoints;
                const angle = progress * Math.PI * 2 * loops;
                const y = progress * CONFIG.treeHeight - CONFIG.treeHeight/2 + 5;
                const r = ((1 - progress) * CONFIG.baseRadius + 2.5) * 1.1;
                const x = Math.cos(angle) * r;
                const z = Math.sin(angle) * r;
                positions.push(x, y, z);
                sizes.push(1.2);
                spiralData.push({ base: new THREE.Vector3(x, y, z), angleOffset: angle, radius: r, y: y });
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            const mat = new THREE.PointsMaterial({ color: 0xFFFFFF, size: 1.0, map: texDot, blending: THREE.AdditiveBlending, depthWrite: false, transparent: true, opacity: 1.0 });
            spiralSystem = new THREE.Points(geo, mat);
            scene.add(spiralSystem);
        }

        function create3DHeart() {
            const geo = new THREE.BufferGeometry();
            const positions = [], sizes = [];
            for(let i=0; i<CONFIG.heartPoints; i++) {
                let done = false;
                while(!done) {
                    const x = (Math.random() - 0.5) * 3, y = (Math.random() - 0.5) * 3, z = (Math.random() - 0.5) * 3;
                    const a = x, b = y * 1.2, c = z;
                    const eq = Math.pow(a*a + 2.25*b*b + c*c - 1, 3) - a*a*c*c*c - 0.1125*b*b*c*c*c;
                    if(eq < 0) {
                        const startY = CONFIG.treeHeight/2 + 7;
                        positions.push(x * 1.5, y * 1.5 + startY, z * 1.5);
                        sizes.push(Math.random() * 0.5 + 0.5);
                        heartData.push({ relX: x * 1.5, relY: y * 1.5, relZ: z * 1.5, treeCenterY: startY, centerTarget: new THREE.Vector3(x * 3, y * 3 + 15, z * 3 + 30) });
                        done = true;
                    }
                }
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            const mat = new THREE.PointsMaterial({ color: 0xFF1493, size: 1.0, map: texDot, blending: THREE.AdditiveBlending, depthWrite: false, transparent: true, opacity: 0.8 });
            heartSystem = new THREE.Points(geo, mat);
            scene.add(heartSystem);
        }

        function createBackgroundSnow() {
            const geo = new THREE.BufferGeometry();
            const positions = [];
            for(let i=0; i<400; i++) { positions.push((Math.random() - 0.5) * 150, Math.random() * 100 - 50, (Math.random() - 0.5) * 100 - 20); }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            const mat = new THREE.PointsMaterial({ color: 0xFFFFFF, size: 0.8, map: texHeart, transparent: true, opacity: 0.3, blending: THREE.AdditiveBlending });
            snowSystem = new THREE.Points(geo, mat);
            scene.add(snowSystem);
        }

        // åŠ¨ç”»å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);
            STATE.time += 0.015;

            const systems = [treeSystem.dots, treeSystem.stars, treeSystem.hearts];
            systems.forEach(sys => {
                if (STATE.mode === 'TREE') sys.rotation.y = STATE.time * 0.1;
                else sys.rotation.y += (STATE.targetRotationY - sys.rotation.y) * 0.05;
            });

            for(let i=0; i<treeData.length; i++) {
                const d = treeData[i];
                const positions = d.system.geometry.attributes.position.array;
                const idx = d.geoIndex;
                let target = STATE.mode === 'TREE' ? d.base : d.scatter;
                positions[idx] += (target.x - positions[idx]) * 0.05;
                positions[idx+1] += (target.y - positions[idx+1]) * 0.05;
                positions[idx+2] += (target.z - positions[idx+2]) * 0.05;
            }
            systems.forEach(sys => sys.geometry.attributes.position.needsUpdate = true);

            const spiralPos = spiralSystem.geometry.attributes.position.array;
            for(let i=0; i<CONFIG.spiralPoints; i++) {
                const i3 = i * 3, d = spiralData[i];
                if(STATE.mode === 'TREE') {
                    const currentAngle = d.angleOffset - STATE.time * 0.5;
                    const x = Math.cos(currentAngle) * d.radius, z = Math.sin(currentAngle) * d.radius;
                    spiralPos[i3] += (x - spiralPos[i3]) * 0.1;
                    spiralPos[i3+1] += (d.y - spiralPos[i3+1]) * 0.1;
                    spiralPos[i3+2] += (z - spiralPos[i3+2]) * 0.1;
                } else {
                    spiralPos[i3] += (d.base.x * 2 - spiralPos[i3]) * 0.05;
                    spiralPos[i3+1] += (d.base.y - spiralPos[i3+1]) * 0.05;
                    spiralPos[i3+2] += (d.base.z * 2 - spiralPos[i3+2]) * 0.05;
                }
            }
            spiralSystem.geometry.attributes.position.needsUpdate = true;

            const heartPos = heartSystem.geometry.attributes.position.array;
            if (STATE.mode === 'TREE') heartSystem.rotation.y = -STATE.time * 0.8;
            else heartSystem.rotation.y += (0 - heartSystem.rotation.y) * 0.05; 
            
            for(let i=0; i<CONFIG.heartPoints; i++) {
                const i3 = i * 3, d = heartData[i];
                let tx, ty, tz;
                if (STATE.mode === 'TREE') { tx = d.relX; ty = d.relY + d.treeCenterY; tz = d.relZ; } 
                else { tx = d.centerTarget.x; ty = d.centerTarget.y; tz = d.centerTarget.z; }
                heartPos[i3] += (tx - heartPos[i3]) * 0.05;
                heartPos[i3+1] += (ty - heartPos[i3+1]) * 0.05;
                heartPos[i3+2] += (tz - heartPos[i3+2]) * 0.05;
            }
            heartSystem.geometry.attributes.position.needsUpdate = true;

            const snowP = snowSystem.geometry.attributes.position.array;
            for(let i=0; i<400; i++) {
                const i3 = i * 3;
                snowP[i3+1] -= 0.05;
                if(snowP[i3+1] < -20) snowP[i3+1] = 40;
            }
            snowSystem.geometry.attributes.position.needsUpdate = true;

            if(composer) composer.render(); else renderer.render(scene, camera);
        }

        // -----------------------------------------------------------
        // MediaPipe åˆå§‹åŒ–é€»è¾‘
        // -----------------------------------------------------------
        async function initMediaPipe() {
            const videoElement = document.getElementById('video-feed');
            const statusElement = document.getElementById('gesture-detected');
            
            // ç¡®ä¿3Då…ˆæ¸²æŸ“
            await new Promise(r => setTimeout(r, 500));
            
            if (typeof Hands === 'undefined' || typeof Camera === 'undefined') {
                console.warn("MediaPipe åº“åŠ è½½å¤±è´¥ï¼Œä»…å±•ç¤º3Dæ•ˆæœ");
                return;
            }

            try {
                // ä½¿ç”¨ unpkg æºï¼Œå°è¯•åŠ è½½ hand æ¨¡å‹
                const hands = new Hands({locateFile: (file) => `https://unpkg.com/@mediapipe/hands/${file}`});
                
                hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 0,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                
                hands.onResults((results) => {
                    const loader = document.getElementById('loading');
                    if (loader) loader.style.display = 'none';

                    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                        detectGesture(results.multiHandLandmarks[0]);
                    } else {
                        statusElement.innerText = "æœªæ£€æµ‹åˆ°æ‰‹";
                    }
                });

                const cameraFeed = new Camera(videoElement, {
                    onFrame: async () => { await hands.send({image: videoElement}); },
                    width: 320,
                    height: 240
                });

                await cameraFeed.start();
                
            } catch (error) {
                console.error("Camera/MediaPipe Error:", error);
                statusElement.innerText = "æ‘„åƒå¤´ä¸å¯ç”¨ (ä»…å±•ç¤ºæ¨¡å¼)";
                // å‡ºé”™ä¹Ÿç§»é™¤ loadingï¼Œä¿è¯ç”¨æˆ·èƒ½çœ‹åˆ°åŠ¨ç”»
                const loader = document.getElementById('loading');
                if(loader) loader.style.display = 'none';
            }
        }

        function detectGesture(landmarks) {
            const dist = (i, j) => Math.hypot(landmarks[i].x - landmarks[j].x, landmarks[i].y - landmarks[j].y);
            const thumbTip = 4, indexTip = 8, palm = 9;
            const pinch = dist(thumbTip, indexTip);
            const handX = landmarks[palm].x;

            let gesture = 'ğŸŒ² æ¬£èµæ¨¡å¼';
            if (pinch < 0.05) { gesture = 'ğŸ¤ æŠ“å–æ˜Ÿå…‰'; } 
            else if (dist(8, 0) > 0.4) { gesture = 'ğŸ– æ•£å¼€æ˜Ÿå°˜'; STATE.mode = 'SCATTER'; } 
            else { STATE.mode = 'TREE'; gesture = 'âœŠ èšåˆå›å¿†'; }
            
            if (STATE.mode === 'SCATTER') STATE.targetRotationY = (handX - 0.5) * -3;
            document.getElementById('gesture-detected').innerText = gesture;
        }

        document.getElementById('file-input').addEventListener('change', (e) => {
            if(e.target.files.length) alert("ç…§ç‰‡å·²ä¸Šä¼ åˆ°é­”æ³•åº“ï¼");
        });

        // å¯åŠ¨
        initThree();
        initMediaPipe();

    </script>
</body>
</html>
